#!/usr/bin/env python3
"""
GIDEON AI - SCRIPT DE R√âPARATION AUTOMATIQUE
Diagnostique et r√©pare automatiquement tous les probl√®mes d√©tect√©s
"""

import os
import sys
import subprocess
import time
import platform
import logging
from pathlib import Path

# Configuration logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('logs/gideon_repair.log', 'w')
    ]
)
logger = logging.getLogger("GideonRepair")

class GideonAutoRepair:
    """Syst√®me de r√©paration automatique pour Gideon AI"""
    
    def __init__(self):
        self.project_root = Path(__file__).parent
        self.system_os = platform.system()
        self.issues_found = []
        self.fixes_applied = []
        
        # Cr√©er dossier logs si n√©cessaire
        self.project_root.joinpath("logs").mkdir(exist_ok=True)
        
        logger.info("üîß Gideon AI Auto-Repair System initialis√©")
    
    def print_header(self, title: str):
        """Afficher header format√©"""
        print(f"\n{'='*60}")
        print(f"üîß {title}")
        print(f"{'='*60}")
        logger.info(f"SECTION: {title}")
    
    def print_step(self, step: str, status: str = "INFO"):
        """Afficher √©tape avec status"""
        icons = {"INFO": "‚ÑπÔ∏è", "SUCCESS": "‚úÖ", "WARNING": "‚ö†Ô∏è", "ERROR": "‚ùå", "FIX": "üîß"}
        icon = icons.get(status, "‚ÑπÔ∏è")
        print(f"{icon} {step}")
        logger.info(f"[{status}] {step}")
    
    def run_command(self, command: str, description: str, critical: bool = False) -> bool:
        """Ex√©cuter commande avec gestion d'erreur"""
        self.print_step(f"Ex√©cution: {description}")
        
        try:
            result = subprocess.run(
                command, 
                shell=True, 
                capture_output=True, 
                text=True,
                cwd=self.project_root
            )
            
            if result.returncode == 0:
                self.print_step(f"‚úÖ {description} - SUCC√àS", "SUCCESS")
                return True
            else:
                error_msg = f"{description} - √âCHEC: {result.stderr}"
                self.print_step(error_msg, "ERROR")
                logger.error(f"Command failed: {command}")
                logger.error(f"Error: {result.stderr}")
                
                if critical:
                    self.issues_found.append(f"CRITIQUE: {error_msg}")
                else:
                    self.issues_found.append(error_msg)
                
                return False
                
        except Exception as e:
            error_msg = f"{description} - ERREUR: {e}"
            self.print_step(error_msg, "ERROR")
            logger.error(f"Exception in command: {command} - {e}")
            
            if critical:
                self.issues_found.append(f"CRITIQUE: {error_msg}")
            else:
                self.issues_found.append(error_msg)
            
            return False
    
    def check_python_environment(self):
        """V√©rifier environnement Python"""
        self.print_header("V√âRIFICATION ENVIRONNEMENT PYTHON")
        
        # V√©rifier Python version
        python_version = sys.version_info
        if python_version >= (3, 8):
            self.print_step(f"Python {python_version.major}.{python_version.minor} d√©tect√©", "SUCCESS")
        else:
            self.print_step(f"Python {python_version.major}.{python_version.minor} - VERSION TROP ANCIENNE", "ERROR")
            self.issues_found.append("Python version < 3.8")
        
        # V√©rifier environnement virtuel
        if hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
            self.print_step("Environnement virtuel activ√©", "SUCCESS")
        else:
            self.print_step("Environnement virtuel NON activ√©", "WARNING")
            self.issues_found.append("Environnement virtuel non activ√©")
    
    def install_dependencies(self):
        """Installer/mettre √† jour d√©pendances"""
        self.print_header("INSTALLATION D√âPENDANCES")
        
        # Fichiers requirements √† traiter par ordre de priorit√©
        req_files = [
            ("requirements_production.txt", "D√©pendances production", True),
            ("requirements.txt", "D√©pendances standard", False),
            ("requirements_light.txt", "D√©pendances all√©g√©es", False)
        ]
        
        for req_file, description, critical in req_files:
            req_path = self.project_root / req_file
            
            if req_path.exists():
                self.print_step(f"Installation depuis {req_file}")
                command = f"{sys.executable} -m pip install -r {req_file} --upgrade"
                success = self.run_command(command, description, critical)
                
                if success:
                    self.fixes_applied.append(f"D√©pendances install√©es: {req_file}")
                    break  # Utiliser le premier fichier qui fonctionne
            else:
                self.print_step(f"Fichier {req_file} introuvable", "WARNING")
        
        # Installation sp√©cifique pour macOS
        if self.system_os == "Darwin":
            self.print_step("Optimisations macOS d√©tect√©es")
            
            # Permissions audio macOS
            macos_deps = [
                "pyobjc-framework-AVFoundation",
                "pyobjc-framework-AudioUnit"
            ]
            
            for dep in macos_deps:
                command = f"{sys.executable} -m pip install {dep}"
                self.run_command(command, f"Installation {dep} pour macOS")
    
    def check_audio_system(self):
        """Diagnostiquer syst√®me audio"""
        self.print_header("DIAGNOSTIC SYST√àME AUDIO")
        
        # Test rapide des imports critiques
        audio_modules = [
            ("speech_recognition", "Reconnaissance vocale"),
            ("pyttsx3", "Text-to-Speech"),
            ("sounddevice", "Interface audio"),
            ("numpy", "Traitement num√©rique")
        ]
        
        for module, description in audio_modules:
            try:
                __import__(module)
                self.print_step(f"Module {module} disponible", "SUCCESS")
            except ImportError:
                self.print_step(f"Module {module} MANQUANT", "ERROR")
                self.issues_found.append(f"Module manquant: {module}")
                
                # Tenter installation automatique
                self.print_step(f"Tentative installation {module}", "FIX")
                command = f"{sys.executable} -m pip install {module}"
                if self.run_command(command, f"Installation {module}"):
                    self.fixes_applied.append(f"Module install√©: {module}")
        
        # Test syst√®me audio complet
        self.print_step("Lancement test audio complet")
        test_command = f"{sys.executable} test_audio_system.py"
        
        if self.run_command(test_command, "Test syst√®me audio"):
            self.print_step("Syst√®me audio fonctionnel", "SUCCESS")
        else:
            self.print_step("Probl√®mes d√©tect√©s dans syst√®me audio", "WARNING")
    
    def check_openai_configuration(self):
        """V√©rifier configuration OpenAI"""
        self.print_header("V√âRIFICATION CONFIGURATION OPENAI")
        
        # V√©rifier variable d'environnement
        api_key = os.getenv('OPENAI_API_KEY')
        
        if api_key:
            if api_key.startswith('sk-') and len(api_key) > 20:
                self.print_step("Cl√© OpenAI d√©tect√©e via variable d'environnement", "SUCCESS")
            else:
                self.print_step("Format cl√© OpenAI invalide", "ERROR")
                self.issues_found.append("Cl√© OpenAI format invalide")
        else:
            self.print_step("Variable OPENAI_API_KEY non d√©finie", "WARNING")
            self.print_step("Configuration fallback active dans config.py", "INFO")
        
        # Test connexion API
        try:
            import openai
            from config import config
            
            if config.ai.OPENAI_API_KEY:
                self.print_step("Test rapide connexion OpenAI")
                
                # Test minimal
                client = openai.OpenAI(api_key=config.ai.OPENAI_API_KEY)
                response = client.chat.completions.create(
                    model="gpt-3.5-turbo",
                    messages=[{"role": "user", "content": "Test"}],
                    max_tokens=5,
                    timeout=5
                )
                
                self.print_step("Connexion OpenAI fonctionnelle", "SUCCESS")
                self.fixes_applied.append("API OpenAI valid√©e")
            else:
                self.print_step("Cl√© OpenAI non disponible", "WARNING")
                
        except Exception as e:
            self.print_step(f"Erreur test OpenAI: {e}", "ERROR")
            self.issues_found.append(f"API OpenAI: {e}")
    
    def fix_macos_permissions(self):
        """R√©parer permissions macOS"""
        if self.system_os != "Darwin":
            return
        
        self.print_header("R√âPARATION PERMISSIONS MACOS")
        
        # Permissions microphone
        self.print_step("V√©rification permissions microphone")
        
        try:
            import sounddevice as sd
            devices = sd.query_devices()
            input_devices = [d for d in devices if d['max_input_channels'] > 0]
            
            if input_devices:
                self.print_step(f"{len(input_devices)} devices audio d√©tect√©s", "SUCCESS")
                self.fixes_applied.append("Permissions audio macOS valid√©es")
            else:
                self.print_step("Aucun device d'entr√©e audio d√©tect√©", "ERROR")
                self.issues_found.append("Permissions audio macOS manquantes")
                
                # Instruction utilisateur
                print("\n" + "="*60)
                print("üîß ACTION REQUISE UTILISATEUR:")
                print("1. Aller dans Pr√©f√©rences Syst√®me > Confidentialit√©")
                print("2. Autoriser Terminal/Python pour le Microphone")
                print("3. Red√©marrer ce script")
                print("="*60)
                
        except Exception as e:
            self.print_step(f"Erreur v√©rification audio: {e}", "ERROR")
    
    def optimize_memory_settings(self):
        """Optimiser param√®tres m√©moire"""
        self.print_header("OPTIMISATION M√âMOIRE")
        
        try:
            import psutil
            
            # V√©rifier m√©moire disponible
            memory = psutil.virtual_memory()
            available_gb = memory.available / (1024**3)
            
            if available_gb >= 2.0:
                self.print_step(f"M√©moire disponible: {available_gb:.1f}GB", "SUCCESS")
            elif available_gb >= 1.0:
                self.print_step(f"M√©moire disponible: {available_gb:.1f}GB - LIMITE", "WARNING")
                self.issues_found.append("M√©moire syst√®me faible")
            else:
                self.print_step(f"M√©moire disponible: {available_gb:.1f}GB - CRITIQUE", "ERROR")
                self.issues_found.append("M√©moire syst√®me critique")
            
            # Optimisations GC Python
            import gc
            gc.set_threshold(700, 10, 10)  # Plus agressif
            self.print_step("Param√®tres Garbage Collector optimis√©s", "SUCCESS")
            self.fixes_applied.append("GC Python optimis√©")
            
        except ImportError:
            self.print_step("Module psutil non disponible", "WARNING")
    
    def create_startup_script(self):
        """Cr√©er script de d√©marrage optimis√©"""
        self.print_header("CR√âATION SCRIPT D√âMARRAGE")
        
        startup_script = '''#!/bin/bash
# Gideon AI - Script de d√©marrage optimis√©

echo "üöÄ D√©marrage Gideon AI..."

# Activer environnement virtuel
if [ -d "venv_gideon_production" ]; then
    source venv_gideon_production/bin/activate
    echo "‚úÖ Environnement virtuel activ√©"
else
    echo "‚ö†Ô∏è Environnement virtuel non trouv√©"
fi

# V√©rifier variable OpenAI
if [ -z "$OPENAI_API_KEY" ]; then
    echo "‚ö†Ô∏è Variable OPENAI_API_KEY non d√©finie"
    echo "üí° Export recommand√©: export OPENAI_API_KEY='your-key-here'"
fi

# Lancer Gideon optimis√©
echo "ü§ñ Lancement Gideon AI Optimis√©..."
python3 gideon_main_optimized.py

echo "üëã Gideon AI arr√™t√©"
'''
        
        try:
            script_path = self.project_root / "start_gideon.sh"
            with open(script_path, 'w') as f:
                f.write(startup_script)
            
            # Rendre ex√©cutable
            os.chmod(script_path, 0o755)
            
            self.print_step("Script de d√©marrage cr√©√©: start_gideon.sh", "SUCCESS")
            self.fixes_applied.append("Script d√©marrage cr√©√©")
            
        except Exception as e:
            self.print_step(f"Erreur cr√©ation script: {e}", "ERROR")
    
    def run_final_test(self):
        """Test final du syst√®me complet"""
        self.print_header("TEST FINAL SYST√àME")
        
        # Test audio complet
        self.print_step("Test final syst√®me audio")
        test_command = f"{sys.executable} test_audio_system.py"
        
        if self.run_command(test_command, "Test audio final"):
            self.print_step("‚úÖ Syst√®me audio OP√âRATIONNEL", "SUCCESS")
        else:
            self.print_step("‚ùå Syst√®me audio n√©cessite attention", "WARNING")
        
        # Test import core modules
        core_modules = [
            "core.audio_manager_optimized",
            "core.assistant_core_production", 
            "core.logger",
            "core.memory_monitor"
        ]
        
        for module in core_modules:
            try:
                __import__(module)
                self.print_step(f"Module {module} OK", "SUCCESS")
            except ImportError as e:
                self.print_step(f"Module {module} ERREUR: {e}", "ERROR")
                self.issues_found.append(f"Import module: {module}")
    
    def generate_report(self):
        """G√©n√©rer rapport de r√©paration"""
        self.print_header("RAPPORT DE R√âPARATION")
        
        print(f"\nüìä R√âSUM√â:")
        print(f"   üîß Corrections appliqu√©es: {len(self.fixes_applied)}")
        print(f"   ‚ö†Ô∏è Probl√®mes d√©tect√©s: {len(self.issues_found)}")
        
        if self.fixes_applied:
            print(f"\n‚úÖ CORRECTIONS APPLIQU√âES:")
            for fix in self.fixes_applied:
                print(f"   ‚Ä¢ {fix}")
        
        if self.issues_found:
            print(f"\n‚ö†Ô∏è PROBL√àMES RESTANTS:")
            for issue in self.issues_found:
                print(f"   ‚Ä¢ {issue}")
        
        # Score de sant√©
        total_checks = len(self.fixes_applied) + len(self.issues_found)
        if total_checks > 0:
            health_score = (len(self.fixes_applied) / total_checks) * 100
        else:
            health_score = 100
        
        print(f"\nüè• SCORE DE SANT√â: {health_score:.1f}%")
        
        if health_score >= 90:
            print("üéâ SYST√àME GIDEON AI PR√äT POUR PRODUCTION!")
            return True
        elif health_score >= 70:
            print("‚ö†Ô∏è Syst√®me fonctionnel mais avec am√©liorations possibles")
            return True
        else:
            print("‚ùå Syst√®me n√©cessite attention avant utilisation")
            return False
    
    def run_complete_repair(self):
        """Ex√©cuter r√©paration compl√®te"""
        print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë               üîß GIDEON AI AUTO-REPAIR SYSTEM               ‚ïë
‚ïë                     R√âPARATION AUTOMATIQUE                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """)
        
        start_time = time.time()
        
        try:
            # S√©quence de r√©paration
            self.check_python_environment()
            self.install_dependencies()
            self.check_audio_system()
            self.check_openai_configuration()
            self.fix_macos_permissions()
            self.optimize_memory_settings()
            self.create_startup_script()
            self.run_final_test()
            
            # Rapport final
            system_ready = self.generate_report()
            
            duration = time.time() - start_time
            
            print(f"\n‚è±Ô∏è Dur√©e totale: {duration:.1f} secondes")
            
            if system_ready:
                print(f"\nüöÄ PR√äT √Ä LANCER:")
                print(f"   ./start_gideon.sh")
                print(f"   OU")
                print(f"   python3 gideon_main_optimized.py")
                return 0
            else:
                print(f"\nüîß ACTIONS REQUISES - Consultez le rapport ci-dessus")
                return 1
                
        except KeyboardInterrupt:
            print(f"\n‚å®Ô∏è R√©paration interrompue par utilisateur")
            return 2
        except Exception as e:
            print(f"\n‚ùå Erreur critique: {e}")
            logger.error(f"Critical error in repair: {e}")
            return 3

def main():
    """Point d'entr√©e principal"""
    repair_system = GideonAutoRepair()
    exit_code = repair_system.run_complete_repair()
    sys.exit(exit_code)

if __name__ == "__main__":
    main() 